GIT - база данных для истории разработки проектов. Он хранит все версии файлов, как новых, так уже и несуществующих. GIT позволяет обмениваться файлами между коллегами без особых проблем.

ИНИЦИЛИЗАЦИЯ ПРОЕКТОВ:
	
	git init [project name]

СКАЧИВАНИЕ ПРОЕКТА ИЗ УДАЛЁННОГО РЕПОЗИТОРИЯ:

	git clone [project url]

КОНФИГУРАЦИЯ ПРОЕКТА:
	
	В состав GIT входит утилита git config, которая позволяет просматривать и настраивать параметры, контролирующие аме аспекты Git, а также его внешний вид. Параметры могут быть сохранены на трёх уровнях:
		1. Файл [path]/etc/gitconfig содержит значения, общие для всех пользователей системы и для всех их репозиториев. Если при запуске git config указать параметр --system, то параметры будут читаться и сохраняться именно в этот файл.
		2. Файл ~/.gitconfig или ~/.config/git/config хранит настройки конкретного пользователя. Этот файл используется при указании параметра --global и применяется ко всем репозиториям, с которыми вы работаете в текущей системе.
		3. Файл config в каталоге Git (т. е. .git/config) репозитория, который вы используете в данный момент, хранит настройки конкретного репозитория. Вы можете заставить Git читать и писать в этот файл с помощью параметра --local, но на самом деле это значение по умолчанию. Неудивительно, что вам нужно находиться где-то в репозитории Git, чтобы эта опция работала правильно.

	Имя пользователя:

	git config user.name "имя"
	git config user.email "почта"		

	Чтобы посмотреть все установленные настройки и узнать где именно они заданы, используйте команду:

		git config --list --show-origin

	Настройки по умолчанию:

		git config --global init.defaultBranch "main"

	Проверка настроек:

		git config --list

	Можно также чекать конкретный ключ, для это нужно написать:

		git config <key>

	статус репозитория можно посмотреть с помощью команды:

		git status


Добавление файла в репозиторий:
	
	echo 'Содержимое файла' > <Имя файла>

	Прииер:

	echo "Hello, world" > README.md

Добавление файлов в репозиторий происходит в два шага:
	
	1. git add <Имя файла>
	
	После этого файл находится в состоянии "готов к фиксации", ну или по-другому, файлы попадают в индекс. Под фиксацией понимается окончательное добавление в репозиторий с помощью коммита. Коммит - это операция, которая берёт все подготовленные файлы, а их может быть сколько угодно, и отпраляет в репозиторий как единое целое:

	2. git commit -m 'add README.md'

	Флаг -m означает message, тобишь описанеи коммита. Это необязательная часть, но тогда откроется редактор, где необходимо будет добавить описание коммита.
	РЕКОМЕНДУЕТСЯ ДЕЛАТЬ ОСМЫСЛЕННЫЕ ОПИСАНИЯ - ЭТО ХОРОШИЙ ТОН. 

	Сделано это всё для удобства прогеров. Не все файлы, изменённые или созданные во время разработки, хочется добавлять одним коммитом.

	Главный прикол коммита в том, что это какое-то логически завершенное изменение. Оно может быть, как большим, так и не очень, ГЛАВНОЕ, чтобы коммит был атомарным, то есть ВЫПОЛНЯЛ РОВНО ОДНУ ЗАДАЧУ. 
	

ПОВСЕДНЕВНАЯ РАБОТА:
	
	Просмотр изменений между рабочей директорией и промежуточной областью(индесом):

	git diff [file]


	Просмотр всех изменений между промежуточной областью и репозитория:

	git diff --staged [file]


	Отмена изменений в рабочей директории. Эта операция не подлежит восстановлению:

	git chekout -- [file]


	Вернет репозиторий в предыдущее рабочее состояние:

	git reset [file]

	Создаст новый коммит с изменениями, добалвенными в промежуточную область(индекс). Коммит должен иметь меседж:

	git commit


	Удалит файл из рабочей директории и промежуточной области(индекса):

	git rm [file]


	Поместит текущее изменение в вашем рабочем каталоге в тайник для дальнейшего использования:

	git stash


	Применение сохраненного содержимого тайника в рабочую директорию и последующие очищение тайника:

	git stash pop


	Удаление определённого тайника из всех предыдущих тайников:

	git stash drop


МОДЕЛЬ ВЕТВЛЕНИЯ Git:
	
	Перечисление всех веток в репозитории:

	git branch [-a]


	Создание новой ветки:

	git branch [branch_name]


	Переключение рабочей директории на указанную ветку. С -b будет создана новая ветка, если её не существет:

	git checkout [-b][branch_name]


	Присоединение указанной ветки к вашей текущей ветке(где вы сейчас находитесь):

	git merge [from name]


	Удаляет выбранную ветку, если она уже объединена с какой-либо дургой. -D вместо -d принудительно удаляет:

	git branch -d [name]


ПРОСМОТР СВОЕЙ РАБОТЫ:

	наиболее распространённые опции для команды git log:

	-p  				показывает патч для каждого коммита

	--stat  			показывает статистику изменённых файлов

	--shortstat  		отображает строку с кол-вом вставок/изменений/удалений для команды --stat

	--name-only  		список изменённых файлов после инфы о коммите

	--name-status  		спиоск файлов, которые добавлен/изменены/удалены

	--abbrev-commit  	Показывает только несколько символов SHA-1

	--relative-date  	Отображает дату в относительном формате

	--graph  			ASCII граф с ветвлениями и историей слияний.

	--pretty  			Показывает коммиты в альтернативном формате.

	--oneline  			


	Выводит историю коммитов. -n count ограничивает список вывода до послених n:

	git log [-n count]


	Есть удобные опции для ограничения вывода по времени. Это --since, --until:

	git log --since=2.week


	Флаг -p выводит diff для каждого коммита:

	git log -p(--patch) 

	git log -p -2 # цифра значит количество выведенных записей. 


	Если необходимо вывести сокращенную статистику, то воспльзуемся данной командой:

	git log --stat # также можно использовать цифру, как в примере ранее.


	След команда меняет формат вывода и делает его более удобным. Это --pretty. Опция oneline выводит каждый коммит в одну строчку для более удобного просмотра. Есть опции short, full, fuller, выводят разное количество инфы:

	git log --pretty=oneline

		git log --pretty=full

		благодаря --graph можно увидеть небольшой граф в формате ASCII, который показывает текущую ветку и историю слияний:

		git log --pretty=format"" --graph 


	Список коммитов, которые присутствуют в текущей ветке и не объединены. Ref может быть именем ветки именем тега:

	git log ref...


	Список коммитов, которые присутствуют в ссылке и не объеденены в ткущую ветвь:

	git log ...ref


	Перечисление операций (чекауты или коммиты) выполненые в локальном репозитории:

	git reflog

	Наиболее интересной опцией является format, которая позволяет указать формат для вывода инрформации:

	git log --pretty=format""

	Таблица опций для git log --pretty=format"":

		%H  		Хеш коммита

		%h  		сокращённый хеш коммита

		%T  		Хеш дерева

		%t  		Сокращённый хеш дерева

		%P  		Хеш родителей 

		%p  		Сокращённый хеш родителей 

		%an  		Имя автора

		%ae  		Электронная почта автора

		%ad  		Дата автора(Формат можно задать опцией --date=option)

		%ar  		Относительная дата автора

		%cn  		Имя коммитера

		%ce  		Электронная почта коммитера

		%cd  		Дата коммитера

		%cr  		Относительная дата коммитера

		%s  		Содержание

ПОМЕТКА ИЗВЕСТНЫХ КОММИИТОВ:
	
	Список всех тегов:

	git tag


	Создание ссылки на тег с именем name для текущего коммита. Добавить commit sha, чтоб пометить конкретный коммит, вместо текущего.


	git tag [name] [commit sha]


	Создание объект тега с именем name для текущего commit'а:

	git tad -a [name] [commit sha]


	Удаление тега из локального репозитория:

	git tag -d



ОТМЕНА ИЗМЕНЕНИЙ:
	
	Чтоб удалить ненужные файлы из индекса, необходимо воспользоваться командой, которая сбрасывает изменения для определённого каталога:

	git reset HEAD <file>

	Создание нового commita, отменяя изменения из указанного commit'a. Он порождает инверсию изменений:

	git revert [commit sha]



СИНХРОНИЗАЦИЯ РЕПОЗИТОРИЕВ:
	
	Получать изменения с пульта дистанционного управления, но не обновлять ветви отслеживания:

	git fetch [remote]


	Удалить удаленные ссылки, которые были удалены из remote репозитория:

	git fetch --prune [remote]


	Получить изменения с remote и объединить текущую ветку с веткой на один уровень выше:

	git pull [remote]


	Отправлять локальные изменения на remote. импользование --tags, позволяет отправлять теги:

	git push [--tags] [remote]


	Отправлять локальные ветки на remote репозиторий. Устанавливать его как выше стоящую ветку:

	git push -u [remote] [branch]



ПОНЯТИЯ:
	Commit - объект.
	Branch - ссылка на коммит; может иметь отслеживаемый поток.
	Tag - ссылка(стандартный) или объект(аннотированный).
	Head - место, где сейчас находится рабочая директория.

Теперь не важно, какие изменения делаются в локальном репозитории, на Github все коммиты попадут только после команды 
	git push

Бывает такое, что один разработчик работает над одним проектом с разных комьютеров, на каждом из которых своя собственная копия репозитория. В таком случае, перед началом работы нужно всегда выполнять команду
	git pull --rebase
которая скачивает из внешнего репозитория новые коммиты и добавляет их в локальный репозиторий. 


У git есть команда, которая объединяет в себе удаление и подготовку к коммиту:
	
	git rm [File]


Есть команда для восстановления целой рабочей директории:

	git restore [File]



Чтоб посмотреть кто последний менял конерктную часть кода в файле, то можно ввести следующую команду:
	
	git blame <путь до файла>

Чтоб найти нужные совпадения с указанной строкой во всех файлах проекта, то можно воспользоваться командой:
	
	git grep "ключевая строка"

	git grep -i "ключевая строка" # флаг -i позволяет искать без учёта регистра

	git grep "ключевая строка" <хеш коммита> # поиск в конкретном коммите

	git grep "ключевая строка" $(git rerv-list --all)
	#Производится поиск по всей истории
	#rev-list возвращает список хешей коммитов


чтоб поменять автора или коммитера какого-то определённого коммита, мы можем воспользоваться определёнными командами:
	GIT_AUTHOR_NAME
	GIT_AUTHOR_EMAIL
	GIT_AUTHOR_DATE
	GIT_COMITTER_NAME
	GIT_COMITTER_EMAIL
	GIT_COMITTER_DATE